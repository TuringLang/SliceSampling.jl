<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Gibbsian Polar Slice Sampling · SliceSampling.jl</title><meta name="title" content="Gibbsian Polar Slice Sampling · SliceSampling.jl"/><meta property="og:title" content="Gibbsian Polar Slice Sampling · SliceSampling.jl"/><meta property="twitter:title" content="Gibbsian Polar Slice Sampling · SliceSampling.jl"/><meta name="description" content="Documentation for SliceSampling.jl."/><meta property="og:description" content="Documentation for SliceSampling.jl."/><meta property="twitter:description" content="Documentation for SliceSampling.jl."/><meta property="og:url" content="https://TuringLang.org/SliceSampling.jl/gibbs_polar/"/><meta property="twitter:url" content="https://TuringLang.org/SliceSampling.jl/gibbs_polar/"/><link rel="canonical" href="https://TuringLang.org/SliceSampling.jl/gibbs_polar/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SliceSampling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../general/">General Usage</a></li><li><a class="tocitem" href="../univariate_slice/">Univariate Slice Sampling</a></li><li><a class="tocitem" href="../meta_multivariate/">Meta Multivariate Samplers</a></li><li><a class="tocitem" href="../latent_slice/">Latent Slice Sampling</a></li><li class="is-active"><a class="tocitem" href>Gibbsian Polar Slice Sampling</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Demonstration"><span>Demonstration</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Gibbsian Polar Slice Sampling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Gibbsian Polar Slice Sampling</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TuringLang/SliceSampling.jl/blob/main/docs/src/gibbs_polar.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="polar"><a class="docs-heading-anchor" href="#polar">Gibbsian Polar Slice Sampling</a><a id="polar-1"></a><a class="docs-heading-anchor-permalink" href="#polar" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Gibbsian polar slice sampling (GPSS) is a recent vector-valued slice sampling algorithm proposed by P. Schär, M. Habeck, and D. Rudolf<sup class="footnote-reference"><a id="citeref-SHR2023" href="#footnote-SHR2023">[SHR2023]</a></sup>. It is an computationally efficient variant of polar slice sampler previously proposed by Roberts and Rosenthal<sup class="footnote-reference"><a id="citeref-RR2002" href="#footnote-RR2002">[RR2002]</a></sup>. Unlike other slice sampling algorithms, it operates a Gibbs sampler over polar coordinates, reminiscent of the elliptical slice sampler (ESS). Due to the involvement of polar coordinates, GPSS only works reliably on more than one dimension. However, unlike ESS, GPSS is applicable to any target distribution.</p><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>For a <span>$d$</span>-dimensional target distribution <span>$\pi$</span>, GPSS utilizes the following augmented target distribution:</p><p class="math-container">\[\begin{aligned}
    p(x, T)      &amp;= \varrho_{\pi}^{(0)}(x) \varrho_{\pi}^{(1)}(x) \, \operatorname{Uniform}\left(T; 0, \varrho^1(x)\right) \\
    \varrho_{\pi}^{(0)}(x) &amp;= {\lVert x \rVert}^{1 - d} \\
    \varrho_{\pi}^{(1)}(x) &amp;= {\lVert x \rVert}^{d-1} \pi\left(x\right)
\end{aligned}\]</p><p>As described in Appendix A of the GPSS paper, sampling from <span>$\varrho^{(1)}(x)$</span> in polar coordinates magically targets the augmented target distribution.</p><p>In a high-level view, GPSS operates a Gibbs sampler in the following fashion:</p><p class="math-container">\[\begin{aligned}
T_n      &amp;\sim \operatorname{Uniform}\left(0, \varrho^{(1)}\left(x_{n-1}\right)\right) \\
\theta_n &amp;\sim \operatorname{Uniform}\left\{ \theta \in \mathbb{S}^{d-1} \mid \varrho^{(1)}\left(r_{n-1} \theta\right) &gt; T_n \right\} \\
r_n      &amp;\sim \operatorname{Uniform}\left\{ r \in \mathbb{R}_{\geq 0} \mid \varrho^{(1)}\left(r \theta_n\right) &gt; T_n \right\} \\
x_n      &amp;= \theta_n r_n,
\end{aligned}\]</p><p>where <span>$T_n$</span> is the usual acceptance threshold auxiliary variable, while <span>$\theta$</span> and <span>$r$</span> are the sampler states in polar coordinates. The Gibbs steps on <span>$\theta$</span> and <span>$r$</span> are implemented through specialized shrinkage procedures.</p><p>The only tunable parameter of the algorithm is the size of the search interval (window) of the shrinkage sampler for the radius variable <span>$r$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>A limitation of the current implementation of GPSS is that the acceptance rate exhibits a heavy tail. That is, occasionally, a single transition might take an excessive amount of time.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The kernel corresponding to this sampler is defined on an <strong>augmented state space</strong> and cannot directly perform a transition on <span>$x$</span>. This also means that the corresponding kernel is not reversible with respect to <span>$x$</span>.</p></div></div><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SliceSampling.GibbsPolarSlice" href="#SliceSampling.GibbsPolarSlice"><code>SliceSampling.GibbsPolarSlice</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GibbsPolarSlice(w; max_proposals)</code></pre><p>Gibbsian polar slice sampling algorithm by P. Schär, M. Habeck, and D. Rudolf <sup class="footnote-reference"><a id="citeref-SHR2023" href="#footnote-SHR2023">[SHR2023]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>w::Real</code>: Initial window size for the radius shrinkage procedure.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>w::Real</code>: Initial window size for the radius shrinkage procedure</li><li><code>max_proposals::Int</code>: Maximum number of proposals allowed until throwing an error (default: <code>10000</code>).</li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>By the nature of polar coordinates, GPSS only works reliably for targets with dimension at least <span>$d \geq 2$</span>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>The initial window size <code>w</code> must be set at least an order of magnitude larger than what is sensible for other slice samplers. Otherwise, a large number of rejections might be experienced.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>When initializing the chain (<em>e.g.</em> the <code>initial_params</code> keyword arguments in <code>AbstractMCMC.sample</code>), it is necessary to inialize from a point <span>$x_0$</span> that has a sensible norm <span>$\lVert x_0 \rVert &gt; 0$</span>, otherwise, the chain will start from a pathologic point in polar coordinates. This might even result in the sampler getting stuck in an infinite loop. (This can be prevented by setting <code>max_proposals</code>.) If <span>$\lVert x_0 \rVert \leq 10^{-5}$</span>, the current implementation will display a warning. </p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>For Turing users: <code>Turing</code> might change <code>initial_params</code> to match the support of the posterior. This might lead to <span>$\lVert x_0 \rVert$</span> being small, even though the vector you passed to<code>initial_params</code> has a sufficiently large norm. If this is suspected, simply try a different initialization value.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TuringLang/SliceSampling.jl/blob/d37f616e3d5c1bf3595e9855d4ae133f5c8f2964/src/multivariate/gibbspolar.jl#L2-L25">source</a></section></article><h2 id="Demonstration"><a class="docs-heading-anchor" href="#Demonstration">Demonstration</a><a id="Demonstration-1"></a><a class="docs-heading-anchor-permalink" href="#Demonstration" title="Permalink"></a></h2><p>As illustrated in the original paper, GPSS shows good performance on heavy-tailed targets despite being a multivariate slice sampler. Consider a 10-dimensional Student-<span>$t$</span> target with 1-degree of freedom (this corresponds to a multivariate Cauchy):</p><pre><code class="language-julia hljs">using Distributions
using Turing
using SliceSampling
using LinearAlgebra
using Plots

@model function demo()
    x ~ MvTDist(1, zeros(10), Matrix(I,10,10))
end
model = demo()

n_samples = 1000
latent_chain = sample(model, externalsampler(LatentSlice(10)), n_samples; initial_params=ones(10))
polar_chain = sample(model, externalsampler(GibbsPolarSlice(10)), n_samples; initial_params=ones(10))

l = @layout [a; b]
p1 = Plots.plot(1:n_samples, latent_chain[:,1,:], ylims=[-10,10], label=&quot;LSS&quot;)
p2 = Plots.plot(1:n_samples, polar_chain[:,1,:],  ylims=[-10,10], label=&quot;GPSS&quot;)
plot(p1, p2, layout = l)
savefig(&quot;student_latent_gpss.svg&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/SliceSampling.jl/SliceSampling.jl/docs/build/student_latent_gpss.svg&quot;</code></pre><p><img src="../student_latent_gpss.svg" alt/></p><p>Clearly, GPSS is better at exploring the deep tails compared to the <a href="../latent_slice/#latent">latent slice sampler</a> (LSS) despite having a similar per-iteration cost.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-SHR2023"><a class="tag is-link" href="#citeref-SHR2023">SHR2023</a>Schär, P., Habeck, M., &amp; Rudolf, D. (2023, July). Gibbsian polar slice sampling. In International Conference on Machine Learning.</li><li class="footnote" id="footnote-RR2002"><a class="tag is-link" href="#citeref-RR2002">RR2002</a>Roberts, G. O., &amp; Rosenthal, J. S. (2002). The polar slice sampler. Stochastic Models, 18(2), 257-280.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../latent_slice/">« Latent Slice Sampling</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Thursday 16 January 2025 00:32">Thursday 16 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
