
module SliceSampling

using AbstractMCMC
using Distributions
using LinearAlgebra
using LogDensityProblems
using Random

# reexports
using AbstractMCMC: sample, MCMCThreads, MCMCDistributed, MCMCSerial
export sample, MCMCThreads, MCMCDistributed, MCMCSerial

# Interfaces
abstract type AbstractSliceSampling <: AbstractMCMC.AbstractSampler end

const DEFAULT_MAX_PROPOSALS = 10_000

"""
    struct Transition

Struct containing the results of the transition.

# Fields
- `params`: Samples generated by the transition.
- `lp::Real`: Log-target density of the samples.
- `info::NamedTuple`: Named tuple containing information about the transition. 
"""
struct Transition{P,L<:Real,I<:NamedTuple}
    "current state of the slice sampling chain"
    params::P

    "log density of the current state"
    lp::L

    "information generated from the sampler"
    info::I
end

"""
    initial_sample(rng, model)

Return the initial sample for the `model` using the random number generator `rng`.

# Arguments
- `rng::Random.AbstractRNG`: Random number generator.
- `model`: The target `LogDensityProblem`.
"""
function initial_sample(::Random.AbstractRNG, ::Any)
    return error(
        "`initial_sample` is not implemented but an initialization wasn't provided. ",
        "Consider supplying an initialization to `initial_params`.",
    )
end

function exceeded_max_prop(max_prop::Int)
    return error(
        "Exceeded maximum number of proposal $(max_prop), ",
        "which indicates an acceptance rate less than $(1/max_prop*100)%. ",
        "A quick fix is to increase `max_prop`, ",
        "but an acceptance rate that is too low often indicates that there is a problem. ",
        "Here are some possible causes:\n",
        "- The model might be broken or degenerate (most likely cause).\n",
        "- The tunable parameters of the sampler are suboptimal.\n",
        "- The initialization is pathologic. (try supplying a (different) `initial_params`)\n",
        "- There might be a bug in the sampler. (if this is suspected, file an issue to `SliceSampling`)\n",
    )
end

## Univariate Slice Sampling Algorithms
export Slice, SliceSteppingOut, SliceDoublingOut

abstract type AbstractUnivariateSliceSampling <: AbstractSliceSampling end

function accept_slice_proposal(
    ::AbstractSliceSampling, ::Any, ::Real, ::Real, ::Real, ::Real, ::Real, ::Real
)
    return true
end

function find_interval end

include("univariate/univariate.jl")
include("univariate/fixedinterval.jl")
include("univariate/steppingout.jl")
include("univariate/doublingout.jl")

## Multivariate slice sampling algorithms
abstract type AbstractMultivariateSliceSampling <: AbstractSliceSampling end

# Meta Multivariate Samplers
export RandPermGibbs, HitAndRun

include("multivariate/randpermgibbs.jl")
include("multivariate/hitandrun.jl")

# Latent Slice Sampling 
export LatentSlice
include("multivariate/latent.jl")

# Gibbsian Polar Slice Sampling 
export GibbsPolarSlice
include("multivariate/gibbspolar.jl")

end
